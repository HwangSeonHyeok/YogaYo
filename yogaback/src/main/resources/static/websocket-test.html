<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>STOMP WebSocket Test</title>
<<<<<<< Updated upstream
  <script src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@7.0.0/bundles/stomp.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
=======
  <!-- CDN을 통해 stomp.js 로드 -->
  <script src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@7.0.0/bundles/stomp.umd.min.js"></script>
>>>>>>> Stashed changes
</head>
<body>
<h1>STOMP WebSocket Test</h1>

<div>
  <label for="token">JWT Token:</label>
  <input type="text" id="token" style="width: 300px;">
  <button id="connectBtn">Connect</button>
  <button id="disconnectBtn">Disconnect</button>
</div>

<div>
  <label for="roomId">Room ID:</label>
  <input type="text" id="roomId" value="room123">
  <button id="subscribeBtn">Subscribe to Room</button>
</div>

<div>
  <label for="action">Action:</label>
  <select id="action">
    <option value="enter">Enter Room</option>
    <option value="ready">Ready</option>
    <option value="signal">Signal</option>
    <option value="iceCandidate">ICE Candidate</option>
    <option value="heartbeat">Heartbeat</option>
  </select>
</div>

<div>
  <label for="messageInput">Message:</label>
  <input type="text" id="messageInput">
  <button id="sendBtn">Send Message</button>
</div>

<pre id="output" style="border:1px solid #ccc; padding:10px; width:80%; height:200px; overflow:auto;"></pre>

<script>
  let client = null;
  let connected = false;

  function log(message) {
    console.log(message);
    document.getElementById("output").textContent += message + "\n";
  }

  document.getElementById('connectBtn').addEventListener('click', function() {
    const token = document.getElementById('token').value;
    if (!token) {
      alert('Please enter a JWT token');
      return;
    }

    log("Attempting to connect with token: " + token.substring(0, 20) + "...");

    // 기존 연결이 있다면 정리
    if (client && connected) {
      client.deactivate();
      connected = false;
    }

    client = new StompJs.Client({
      brokerURL: "ws://j12d104.p.ssafy.io/ws",
      connectHeaders: {
<<<<<<< Updated upstream
        'token': token
=======
        'Authorization': 'Bearer ' + cleanToken,
        'host': 'j12d104.p.ssafy.io',
        'accept-version': '1.2',
        'heart-beat': '10000,10000'
>>>>>>> Stashed changes
      },
      reconnectDelay: 5000,
      heartbeatIncoming: 4000,
      heartbeatOutgoing: 4000,
      webSocketFactory: () => {
<<<<<<< Updated upstream
        return new SockJS("http://localhost:8080/ws");
      },
      debug: function(str) {
        log("STOMP Debug: " + str);
=======
        const ws = new WebSocket("ws://j12d104.p.ssafy.io/ws", ["v10.stomp", "v11.stomp"]);
        ws.onerror = (event) => {
          console.error("WebSocket Error:", event);
          console.error("WebSocket ReadyState:", ws.readyState);
          document.getElementById("output").textContent += 
            `WebSocket Error: ${JSON.stringify(event)}\nReadyState: ${ws.readyState}\n`;
        };
        ws.onopen = () => {
          console.log("WebSocket connection opened");
          document.getElementById("output").textContent += "WebSocket connection opened\n";
        };
        ws.onclose = (event) => {
          console.log("WebSocket connection closed:", event);
          document.getElementById("output").textContent += `WebSocket connection closed: ${JSON.stringify(event)}\n`;
        };
        return ws;
      },
      debug: function(str) {
        console.log(str);
        // STOMP 프레임 정보를 더 자세히 표시
        if (str.includes('>>> CONNECT')) {
          document.getElementById("output").textContent += "\n=== CONNECT Frame ===\n";
          document.getElementById("output").textContent += str + "\n";
          // 헤더 정보를 별도로 표시
          const headers = client.connectHeaders;
          document.getElementById("output").textContent += "\nHeaders:\n";
          Object.keys(headers).forEach(key => {
            document.getElementById("output").textContent += `${key}: ${headers[key]}\n`;
          });
          document.getElementById("output").textContent += "==================\n\n";
        } else {
          document.getElementById("output").textContent += str + "\n";
        }
>>>>>>> Stashed changes
      }
    });

    client.onConnect = function(frame) {
      connected = true;
      log("Connected successfully: " + JSON.stringify(frame));
    };

    client.onStompError = function(frame) {
      log("STOMP Error: " + JSON.stringify(frame));
      connected = false;
    };

    client.onWebSocketError = function(event) {
      log("WebSocket Error: " + JSON.stringify(event));
      if (event.target && event.target.readyState) {
        log("WebSocket State: " + event.target.readyState);
      }
      connected = false;
    };

    client.onWebSocketClose = function(event) {
      log("WebSocket Closed: " + JSON.stringify(event));
      if (event.code) {
        log("Close Code: " + event.code);
      }
      if (event.reason) {
        log("Close Reason: " + event.reason);
      }
      connected = false;
    };

    try {
      client.activate();
      log("Client activation initiated");
    } catch (error) {
      log("Error activating client: " + error.message);
      connected = false;
    }
  });

  document.getElementById('disconnectBtn').addEventListener('click', function() {
    if(client && connected){
      client.deactivate();
      connected = false;
      log("Disconnected");
    }
  });

  document.getElementById('subscribeBtn').addEventListener('click', function() {
    if(client && connected){
      let roomId = document.getElementById('roomId').value;
      const topics = [
        "/topic/room/" + roomId,
        "/topic/room/" + roomId + "/allReady",
        "/topic/room/" + roomId + "/courseStarted",
        "/topic/room/" + roomId + "/userReady",
        "/topic/room/" + roomId + "/signal",
        "/topic/room/" + roomId + "/iceCandidate",
        "/topic/room/" + roomId + "/heartbeat",
        "/user/queue/errors"
      ];

      topics.forEach(topic => {
<<<<<<< Updated upstream
        try {
          const subscription = client.subscribe(topic, function(message) {
            log("Received from " + topic + ": " + message.body);
          });
          log("Subscribed to " + topic + " with subscription ID: " + subscription.id);
        } catch (error) {
          log("Error subscribing to " + topic + ": " + error.message);
        }
=======
        client.subscribe(topic, function(message) {
          console.log("Received message from " + topic + ":", message);
          document.getElementById("output").textContent += 
            `Received from ${topic}:\n${JSON.stringify(JSON.parse(message.body), null, 2)}\n`;
        }, {
          'ack': 'client',
          'id': 'sub-' + topic
        });
        document.getElementById("output").textContent += "Subscribed to " + topic + "\n";
>>>>>>> Stashed changes
      });
    } else {
      log("Cannot subscribe: Client not connected");
    }
  });

  document.getElementById('sendBtn').addEventListener('click', function() {
    if(client && connected){
      let roomId = document.getElementById('roomId').value;
      let action = document.getElementById('action').value;
      let messageInput = document.getElementById('messageInput').value;

      let payload = {
        action: action,
        message: {}
      };

      switch(action) {
        case "enter":
          payload.message = {
            roomId: roomId,
<<<<<<< Updated upstream
            userId: "1",
            userNickName: "Tester",
            userProfile: "profileUrl"
=======
>>>>>>> Stashed changes
          };
          break;
        case "ready":
          payload.message = {
            ready: true
          };
          break;
        case "signal":
          payload.message = {
            signal: messageInput
          };
          break;
        case "iceCandidate":
          payload.message = {
            candidate: messageInput
          };
          break;
        case "heartbeat":
          payload.message = {};
          break;
      }

      try {
        client.publish({
          destination: "/app/action/" + roomId,
          body: JSON.stringify(payload)
        });
        log("Sent: " + JSON.stringify(payload));
      } catch (error) {
        log("Error sending message: " + error.message);
      }
    } else {
      log("Cannot send message: Client not connected");
    }
  });
</script>
</body>
</html>
